{"ast":null,"code":"/*! ColReorder 1.3.0\n * Â©2010-2015 SpryMedia Ltd - datatables.net/license\n */\n\n/**\n * @summary     ColReorder\n * @description Provide the ability to reorder columns in a DataTable\n * @version     1.3.0\n * @file        dataTables.colReorder.js\n * @author      SpryMedia Ltd (www.sprymedia.co.uk)\n * @contact     www.sprymedia.co.uk/contact\n * @copyright   Copyright 2010-2014 SpryMedia Ltd.\n *\n * This source file is free software, available under the following license:\n *   MIT license - http://datatables.net/license/mit\n *\n * This source file is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.\n *\n * For details please refer to: http://www.datatables.net\n */\n(function (factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD\n    define(['jquery', 'datatables.net'], function ($) {\n      return factory($, window, document);\n    });\n  } else if (typeof exports === 'object') {\n    // CommonJS\n    module.exports = function (root, $) {\n      if (!root) {\n        root = window;\n      }\n\n      if (!$ || !$.fn.dataTable) {\n        $ = require('datatables.net')(root, $).$;\n      }\n\n      return factory($, root, root.document);\n    };\n  } else {\n    // Browser\n    factory(jQuery, window, document);\n  }\n})(function ($, window, document, undefined) {\n  'use strict';\n\n  var DataTable = $.fn.dataTable;\n  /**\n   * Switch the key value pairing of an index array to be value key (i.e. the old value is now the\n   * key). For example consider [ 2, 0, 1 ] this would be returned as [ 1, 2, 0 ].\n   *  @method  fnInvertKeyValues\n   *  @param   array aIn Array to switch around\n   *  @returns array\n   */\n\n  function fnInvertKeyValues(aIn) {\n    var aRet = [];\n\n    for (var i = 0, iLen = aIn.length; i < iLen; i++) {\n      aRet[aIn[i]] = i;\n    }\n\n    return aRet;\n  }\n  /**\n   * Modify an array by switching the position of two elements\n   *  @method  fnArraySwitch\n   *  @param   array aArray Array to consider, will be modified by reference (i.e. no return)\n   *  @param   int iFrom From point\n   *  @param   int iTo Insert point\n   *  @returns void\n   */\n\n\n  function fnArraySwitch(aArray, iFrom, iTo) {\n    var mStore = aArray.splice(iFrom, 1)[0];\n    aArray.splice(iTo, 0, mStore);\n  }\n  /**\n   * Switch the positions of nodes in a parent node (note this is specifically designed for\n   * table rows). Note this function considers all element nodes under the parent!\n   *  @method  fnDomSwitch\n   *  @param   string sTag Tag to consider\n   *  @param   int iFrom Element to move\n   *  @param   int Point to element the element to (before this point), can be null for append\n   *  @returns void\n   */\n\n\n  function fnDomSwitch(nParent, iFrom, iTo) {\n    var anTags = [];\n\n    for (var i = 0, iLen = nParent.childNodes.length; i < iLen; i++) {\n      if (nParent.childNodes[i].nodeType == 1) {\n        anTags.push(nParent.childNodes[i]);\n      }\n    }\n\n    var nStore = anTags[iFrom];\n\n    if (iTo !== null) {\n      nParent.insertBefore(nStore, anTags[iTo]);\n    } else {\n      nParent.appendChild(nStore);\n    }\n  }\n  /**\n   * Plug-in for DataTables which will reorder the internal column structure by taking the column\n   * from one position (iFrom) and insert it into a given point (iTo).\n   *  @method  $.fn.dataTableExt.oApi.fnColReorder\n   *  @param   object oSettings DataTables settings object - automatically added by DataTables!\n   *  @param   int iFrom Take the column to be repositioned from this point\n   *  @param   int iTo and insert it into this point\n   *  @param   bool drop Indicate if the reorder is the final one (i.e. a drop)\n   *    not a live reorder\n   *  @returns void\n   */\n\n\n  $.fn.dataTableExt.oApi.fnColReorder = function (oSettings, iFrom, iTo, drop) {\n    var i,\n        iLen,\n        j,\n        jLen,\n        iCols = oSettings.aoColumns.length,\n        nTrs,\n        oCol;\n\n    var attrMap = function attrMap(obj, prop, mapping) {\n      if (!obj[prop] || typeof obj[prop] === 'function') {\n        return;\n      }\n\n      var a = obj[prop].split('.');\n      var num = a.shift();\n\n      if (isNaN(num * 1)) {\n        return;\n      }\n\n      obj[prop] = mapping[num * 1] + '.' + a.join('.');\n    };\n    /* Sanity check in the input */\n\n\n    if (iFrom == iTo) {\n      /* Pointless reorder */\n      return;\n    }\n\n    if (iFrom < 0 || iFrom >= iCols) {\n      this.oApi._fnLog(oSettings, 1, \"ColReorder 'from' index is out of bounds: \" + iFrom);\n\n      return;\n    }\n\n    if (iTo < 0 || iTo >= iCols) {\n      this.oApi._fnLog(oSettings, 1, \"ColReorder 'to' index is out of bounds: \" + iTo);\n\n      return;\n    }\n    /*\n     * Calculate the new column array index, so we have a mapping between the old and new\n     */\n\n\n    var aiMapping = [];\n\n    for (i = 0, iLen = iCols; i < iLen; i++) {\n      aiMapping[i] = i;\n    }\n\n    fnArraySwitch(aiMapping, iFrom, iTo);\n    var aiInvertMapping = fnInvertKeyValues(aiMapping);\n    /*\n     * Convert all internal indexing to the new column order indexes\n     */\n\n    /* Sorting */\n\n    for (i = 0, iLen = oSettings.aaSorting.length; i < iLen; i++) {\n      oSettings.aaSorting[i][0] = aiInvertMapping[oSettings.aaSorting[i][0]];\n    }\n    /* Fixed sorting */\n\n\n    if (oSettings.aaSortingFixed !== null) {\n      for (i = 0, iLen = oSettings.aaSortingFixed.length; i < iLen; i++) {\n        oSettings.aaSortingFixed[i][0] = aiInvertMapping[oSettings.aaSortingFixed[i][0]];\n      }\n    }\n    /* Data column sorting (the column which the sort for a given column should take place on) */\n\n\n    for (i = 0, iLen = iCols; i < iLen; i++) {\n      oCol = oSettings.aoColumns[i];\n\n      for (j = 0, jLen = oCol.aDataSort.length; j < jLen; j++) {\n        oCol.aDataSort[j] = aiInvertMapping[oCol.aDataSort[j]];\n      } // Update the column indexes\n\n\n      oCol.idx = aiInvertMapping[oCol.idx];\n    } // Update 1.10 optimised sort class removal variable\n\n\n    $.each(oSettings.aLastSort, function (i, val) {\n      oSettings.aLastSort[i].src = aiInvertMapping[val.src];\n    });\n    /* Update the Get and Set functions for each column */\n\n    for (i = 0, iLen = iCols; i < iLen; i++) {\n      oCol = oSettings.aoColumns[i];\n\n      if (typeof oCol.mData == 'number') {\n        oCol.mData = aiInvertMapping[oCol.mData]; // regenerate the get / set functions\n\n        oSettings.oApi._fnColumnOptions(oSettings, i, {});\n      } else if ($.isPlainObject(oCol.mData)) {\n        // HTML5 data sourced\n        attrMap(oCol.mData, '_', aiInvertMapping);\n        attrMap(oCol.mData, 'filter', aiInvertMapping);\n        attrMap(oCol.mData, 'sort', aiInvertMapping);\n        attrMap(oCol.mData, 'type', aiInvertMapping); // regenerate the get / set functions\n\n        oSettings.oApi._fnColumnOptions(oSettings, i, {});\n      }\n    }\n    /*\n     * Move the DOM elements\n     */\n\n\n    if (oSettings.aoColumns[iFrom].bVisible) {\n      /* Calculate the current visible index and the point to insert the node before. The insert\n       * before needs to take into account that there might not be an element to insert before,\n       * in which case it will be null, and an appendChild should be used\n       */\n      var iVisibleIndex = this.oApi._fnColumnIndexToVisible(oSettings, iFrom);\n\n      var iInsertBeforeIndex = null;\n      i = iTo < iFrom ? iTo : iTo + 1;\n\n      while (iInsertBeforeIndex === null && i < iCols) {\n        iInsertBeforeIndex = this.oApi._fnColumnIndexToVisible(oSettings, i);\n        i++;\n      }\n      /* Header */\n\n\n      nTrs = oSettings.nTHead.getElementsByTagName('tr');\n\n      for (i = 0, iLen = nTrs.length; i < iLen; i++) {\n        fnDomSwitch(nTrs[i], iVisibleIndex, iInsertBeforeIndex);\n      }\n      /* Footer */\n\n\n      if (oSettings.nTFoot !== null) {\n        nTrs = oSettings.nTFoot.getElementsByTagName('tr');\n\n        for (i = 0, iLen = nTrs.length; i < iLen; i++) {\n          fnDomSwitch(nTrs[i], iVisibleIndex, iInsertBeforeIndex);\n        }\n      }\n      /* Body */\n\n\n      for (i = 0, iLen = oSettings.aoData.length; i < iLen; i++) {\n        if (oSettings.aoData[i].nTr !== null) {\n          fnDomSwitch(oSettings.aoData[i].nTr, iVisibleIndex, iInsertBeforeIndex);\n        }\n      }\n    }\n    /*\n     * Move the internal array elements\n     */\n\n    /* Columns */\n\n\n    fnArraySwitch(oSettings.aoColumns, iFrom, iTo);\n    /* Search columns */\n\n    fnArraySwitch(oSettings.aoPreSearchCols, iFrom, iTo);\n    /* Array array - internal data anodes cache */\n\n    for (i = 0, iLen = oSettings.aoData.length; i < iLen; i++) {\n      var data = oSettings.aoData[i];\n\n      if (data.anCells) {\n        fnArraySwitch(data.anCells, iFrom, iTo);\n      } // For DOM sourced data, the invalidate will reread the cell into\n      // the data array, but for data sources as an array, they need to\n      // be flipped\n\n\n      if (data.src !== 'dom' && $.isArray(data._aData)) {\n        fnArraySwitch(data._aData, iFrom, iTo);\n      }\n    }\n    /* Reposition the header elements in the header layout array */\n\n\n    for (i = 0, iLen = oSettings.aoHeader.length; i < iLen; i++) {\n      fnArraySwitch(oSettings.aoHeader[i], iFrom, iTo);\n    }\n\n    if (oSettings.aoFooter !== null) {\n      for (i = 0, iLen = oSettings.aoFooter.length; i < iLen; i++) {\n        fnArraySwitch(oSettings.aoFooter[i], iFrom, iTo);\n      }\n    } // Invalidate row cached data for sorting, filtering etc\n\n\n    var api = new $.fn.dataTable.Api(oSettings);\n    api.rows().invalidate();\n    /*\n     * Update DataTables' event handlers\n     */\n\n    /* Sort listener */\n\n    for (i = 0, iLen = iCols; i < iLen; i++) {\n      $(oSettings.aoColumns[i].nTh).off('click.DT');\n\n      this.oApi._fnSortAttachListener(oSettings, oSettings.aoColumns[i].nTh, i);\n    }\n    /* Fire an event so other plug-ins can update */\n\n\n    $(oSettings.oInstance).trigger('column-reorder.dt', [oSettings, {\n      from: iFrom,\n      to: iTo,\n      mapping: aiInvertMapping,\n      drop: drop,\n      // Old style parameters for compatibility\n      iFrom: iFrom,\n      iTo: iTo,\n      aiInvertMapping: aiInvertMapping\n    }]);\n  };\n  /**\n   * ColReorder provides column visibility control for DataTables\n   * @class ColReorder\n   * @constructor\n   * @param {object} dt DataTables settings object\n   * @param {object} opts ColReorder options\n   */\n\n\n  var ColReorder = function ColReorder(dt, opts) {\n    var settings = new $.fn.dataTable.Api(dt).settings()[0]; // Ensure that we can't initialise on the same table twice\n\n    if (settings._colReorder) {\n      return settings._colReorder;\n    } // Allow the options to be a boolean for defaults\n\n\n    if (opts === true) {\n      opts = {};\n    } // Convert from camelCase to Hungarian, just as DataTables does\n\n\n    var camelToHungarian = $.fn.dataTable.camelToHungarian;\n\n    if (camelToHungarian) {\n      camelToHungarian(ColReorder.defaults, ColReorder.defaults, true);\n      camelToHungarian(ColReorder.defaults, opts || {});\n    }\n    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n     * Public class variables\n     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n    /**\n     * @namespace Settings object which contains customisable information for ColReorder instance\n     */\n\n\n    this.s = {\n      /**\n       * DataTables settings object\n       *  @property dt\n       *  @type     Object\n       *  @default  null\n       */\n      \"dt\": null,\n\n      /**\n       * Initialisation object used for this instance\n       *  @property init\n       *  @type     object\n       *  @default  {}\n       */\n      \"init\": $.extend(true, {}, ColReorder.defaults, opts),\n\n      /**\n       * Number of columns to fix (not allow to be reordered)\n       *  @property fixed\n       *  @type     int\n       *  @default  0\n       */\n      \"fixed\": 0,\n\n      /**\n       * Number of columns to fix counting from right (not allow to be reordered)\n       *  @property fixedRight\n       *  @type     int\n       *  @default  0\n       */\n      \"fixedRight\": 0,\n\n      /**\n       * Callback function for once the reorder has been done\n       *  @property reorderCallback\n       *  @type     function\n       *  @default  null\n       */\n      \"reorderCallback\": null,\n\n      /**\n       * @namespace Information used for the mouse drag\n       */\n      \"mouse\": {\n        \"startX\": -1,\n        \"startY\": -1,\n        \"offsetX\": -1,\n        \"offsetY\": -1,\n        \"target\": -1,\n        \"targetIndex\": -1,\n        \"fromIndex\": -1\n      },\n\n      /**\n       * Information which is used for positioning the insert cusor and knowing where to do the\n       * insert. Array of objects with the properties:\n       *   x: x-axis position\n       *   to: insert point\n       *  @property aoTargets\n       *  @type     array\n       *  @default  []\n       */\n      \"aoTargets\": []\n    };\n    /**\n     * @namespace Common and useful DOM elements for the class instance\n     */\n\n    this.dom = {\n      /**\n       * Dragging element (the one the mouse is moving)\n       *  @property drag\n       *  @type     element\n       *  @default  null\n       */\n      \"drag\": null,\n\n      /**\n       * The insert cursor\n       *  @property pointer\n       *  @type     element\n       *  @default  null\n       */\n      \"pointer\": null\n    };\n    /* Constructor logic */\n\n    this.s.dt = settings;\n    this.s.dt._colReorder = this;\n\n    this._fnConstruct();\n\n    return this;\n  };\n\n  $.extend(ColReorder.prototype, {\n    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n     * Public methods\n     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n    /**\n     * Reset the column ordering to the original ordering that was detected on\n     * start up.\n     *  @return {this} Returns `this` for chaining.\n     *\n     *  @example\n     *    // DataTables initialisation with ColReorder\n     *    var table = $('#example').dataTable( {\n     *        \"sDom\": 'Rlfrtip'\n     *    } );\n     *\n     *    // Add click event to a button to reset the ordering\n     *    $('#resetOrdering').click( function (e) {\n     *        e.preventDefault();\n     *        $.fn.dataTable.ColReorder( table ).fnReset();\n     *    } );\n     */\n    \"fnReset\": function fnReset() {\n      this._fnOrderColumns(this.fnOrder());\n\n      return this;\n    },\n\n    /**\n     * `Deprecated` - Get the current order of the columns, as an array.\n     *  @return {array} Array of column identifiers\n     *  @deprecated `fnOrder` should be used in preference to this method.\n     *      `fnOrder` acts as a getter/setter.\n     */\n    \"fnGetCurrentOrder\": function fnGetCurrentOrder() {\n      return this.fnOrder();\n    },\n\n    /**\n     * Get the current order of the columns, as an array. Note that the values\n     * given in the array are unique identifiers for each column. Currently\n     * these are the original ordering of the columns that was detected on\n     * start up, but this could potentially change in future.\n     *  @return {array} Array of column identifiers\n     *\n     *  @example\n     *    // Get column ordering for the table\n     *    var order = $.fn.dataTable.ColReorder( dataTable ).fnOrder();\n     */\n\n    /**\n    * Set the order of the columns, from the positions identified in the\n    * ordering array given. Note that ColReorder takes a brute force approach\n    * to reordering, so it is possible multiple reordering events will occur\n    * before the final order is settled upon.\n    *  @param {array} [set] Array of column identifiers in the new order. Note\n    *    that every column must be included, uniquely, in this array.\n    *  @return {this} Returns `this` for chaining.\n    *\n    *  @example\n    *    // Swap the first and second columns\n    *    $.fn.dataTable.ColReorder( dataTable ).fnOrder( [1, 0, 2, 3, 4] );\n    *\n    *  @example\n    *    // Move the first column to the end for the table `#example`\n    *    var curr = $.fn.dataTable.ColReorder( '#example' ).fnOrder();\n    *    var first = curr.shift();\n    *    curr.push( first );\n    *    $.fn.dataTable.ColReorder( '#example' ).fnOrder( curr );\n    *\n    *  @example\n    *    // Reverse the table's order\n    *    $.fn.dataTable.ColReorder( '#example' ).fnOrder(\n    *      $.fn.dataTable.ColReorder( '#example' ).fnOrder().reverse()\n    *    );\n    */\n    \"fnOrder\": function fnOrder(set, original) {\n      var a = [],\n          i,\n          ien,\n          j,\n          jen;\n      var columns = this.s.dt.aoColumns;\n\n      if (set === undefined) {\n        for (i = 0, ien = columns.length; i < ien; i++) {\n          a.push(columns[i]._ColReorder_iOrigCol);\n        }\n\n        return a;\n      } // The order given is based on the original indexes, rather than the\n      // existing ones, so we need to translate from the original to current\n      // before then doing the order\n\n\n      if (original) {\n        var order = this.fnOrder();\n\n        for (i = 0, ien = set.length; i < ien; i++) {\n          a.push($.inArray(set[i], order));\n        }\n\n        set = a;\n      }\n\n      this._fnOrderColumns(fnInvertKeyValues(set));\n\n      return this;\n    },\n\n    /**\n     * Convert from the original column index, to the original\n     *\n     * @param  {int|array} idx Index(es) to convert\n     * @param  {string} dir Transpose direction - `fromOriginal` / `toCurrent`\n     *   or `'toOriginal` / `fromCurrent`\n     * @return {int|array}     Converted values\n     */\n    fnTranspose: function fnTranspose(idx, dir) {\n      if (!dir) {\n        dir = 'toCurrent';\n      }\n\n      var order = this.fnOrder();\n      var columns = this.s.dt.aoColumns;\n\n      if (dir === 'toCurrent') {\n        // Given an original index, want the current\n        return !$.isArray(idx) ? $.inArray(idx, order) : $.map(idx, function (index) {\n          return $.inArray(index, order);\n        });\n      } else {\n        // Given a current index, want the original\n        return !$.isArray(idx) ? columns[idx]._ColReorder_iOrigCol : $.map(idx, function (index) {\n          return columns[index]._ColReorder_iOrigCol;\n        });\n      }\n    },\n\n    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n     * Private methods (they are of course public in JS, but recommended as private)\n     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n    /**\n     * Constructor logic\n     *  @method  _fnConstruct\n     *  @returns void\n     *  @private\n     */\n    \"_fnConstruct\": function _fnConstruct() {\n      var that = this;\n      var iLen = this.s.dt.aoColumns.length;\n      var table = this.s.dt.nTable;\n      var i;\n      /* Columns discounted from reordering - counting left to right */\n\n      if (this.s.init.iFixedColumns) {\n        this.s.fixed = this.s.init.iFixedColumns;\n      }\n\n      if (this.s.init.iFixedColumnsLeft) {\n        this.s.fixed = this.s.init.iFixedColumnsLeft;\n      }\n      /* Columns discounted from reordering - counting right to left */\n\n\n      this.s.fixedRight = this.s.init.iFixedColumnsRight ? this.s.init.iFixedColumnsRight : 0;\n      /* Drop callback initialisation option */\n\n      if (this.s.init.fnReorderCallback) {\n        this.s.reorderCallback = this.s.init.fnReorderCallback;\n      }\n      /* Add event handlers for the drag and drop, and also mark the original column order */\n\n\n      for (i = 0; i < iLen; i++) {\n        if (i > this.s.fixed - 1 && i < iLen - this.s.fixedRight) {\n          this._fnMouseListener(i, this.s.dt.aoColumns[i].nTh);\n        }\n        /* Mark the original column order for later reference */\n\n\n        this.s.dt.aoColumns[i]._ColReorder_iOrigCol = i;\n      }\n      /* State saving */\n\n\n      this.s.dt.oApi._fnCallbackReg(this.s.dt, 'aoStateSaveParams', function (oS, oData) {\n        that._fnStateSave.call(that, oData);\n      }, \"ColReorder_State\");\n      /* An initial column order has been specified */\n\n\n      var aiOrder = null;\n\n      if (this.s.init.aiOrder) {\n        aiOrder = this.s.init.aiOrder.slice();\n      }\n      /* State loading, overrides the column order given */\n\n\n      if (this.s.dt.oLoadedState && typeof this.s.dt.oLoadedState.ColReorder != 'undefined' && this.s.dt.oLoadedState.ColReorder.length == this.s.dt.aoColumns.length) {\n        aiOrder = this.s.dt.oLoadedState.ColReorder;\n      }\n      /* If we have an order to apply - do so */\n\n\n      if (aiOrder) {\n        /* We might be called during or after the DataTables initialisation. If before, then we need\n         * to wait until the draw is done, if after, then do what we need to do right away\n         */\n        if (!that.s.dt._bInitComplete) {\n          var bDone = false;\n          $(table).on('draw.dt.colReorder', function () {\n            if (!that.s.dt._bInitComplete && !bDone) {\n              bDone = true;\n              var resort = fnInvertKeyValues(aiOrder);\n\n              that._fnOrderColumns.call(that, resort);\n            }\n          });\n        } else {\n          var resort = fnInvertKeyValues(aiOrder);\n\n          that._fnOrderColumns.call(that, resort);\n        }\n      } else {\n        this._fnSetColumnIndexes();\n      } // Destroy clean up\n\n\n      $(table).on('destroy.dt.colReorder', function () {\n        $(table).off('destroy.dt.colReorder draw.dt.colReorder');\n        $(that.s.dt.nTHead).find('*').off('.ColReorder');\n        $.each(that.s.dt.aoColumns, function (i, column) {\n          $(column.nTh).removeAttr('data-column-index');\n        });\n        that.s.dt._colReorder = null;\n        that.s = null;\n      });\n    },\n\n    /**\n     * Set the column order from an array\n     *  @method  _fnOrderColumns\n     *  @param   array a An array of integers which dictate the column order that should be applied\n     *  @returns void\n     *  @private\n     */\n    \"_fnOrderColumns\": function _fnOrderColumns(a) {\n      var changed = false;\n\n      if (a.length != this.s.dt.aoColumns.length) {\n        this.s.dt.oInstance.oApi._fnLog(this.s.dt, 1, \"ColReorder - array reorder does not \" + \"match known number of columns. Skipping.\");\n\n        return;\n      }\n\n      for (var i = 0, iLen = a.length; i < iLen; i++) {\n        var currIndex = $.inArray(i, a);\n\n        if (i != currIndex) {\n          /* Reorder our switching array */\n          fnArraySwitch(a, currIndex, i);\n          /* Do the column reorder in the table */\n\n          this.s.dt.oInstance.fnColReorder(currIndex, i, true);\n          changed = true;\n        }\n      }\n\n      this._fnSetColumnIndexes(); // Has anything actually changed? If not, then nothing else to do\n\n\n      if (!changed) {\n        return;\n      }\n      /* When scrolling we need to recalculate the column sizes to allow for the shift */\n\n\n      if (this.s.dt.oScroll.sX !== \"\" || this.s.dt.oScroll.sY !== \"\") {\n        this.s.dt.oInstance.fnAdjustColumnSizing(false);\n      }\n      /* Save the state */\n\n\n      this.s.dt.oInstance.oApi._fnSaveState(this.s.dt);\n\n      if (this.s.reorderCallback !== null) {\n        this.s.reorderCallback.call(this);\n      }\n    },\n\n    /**\n     * Because we change the indexes of columns in the table, relative to their starting point\n     * we need to reorder the state columns to what they are at the starting point so we can\n     * then rearrange them again on state load!\n     *  @method  _fnStateSave\n     *  @param   object oState DataTables state\n     *  @returns string JSON encoded cookie string for DataTables\n     *  @private\n     */\n    \"_fnStateSave\": function _fnStateSave(oState) {\n      var i, iLen, aCopy, iOrigColumn;\n      var oSettings = this.s.dt;\n      var columns = oSettings.aoColumns;\n      oState.ColReorder = [];\n      /* Sorting */\n\n      if (oState.aaSorting) {\n        // 1.10.0-\n        for (i = 0; i < oState.aaSorting.length; i++) {\n          oState.aaSorting[i][0] = columns[oState.aaSorting[i][0]]._ColReorder_iOrigCol;\n        }\n\n        var aSearchCopy = $.extend(true, [], oState.aoSearchCols);\n\n        for (i = 0, iLen = columns.length; i < iLen; i++) {\n          iOrigColumn = columns[i]._ColReorder_iOrigCol;\n          /* Column filter */\n\n          oState.aoSearchCols[iOrigColumn] = aSearchCopy[i];\n          /* Visibility */\n\n          oState.abVisCols[iOrigColumn] = columns[i].bVisible;\n          /* Column reordering */\n\n          oState.ColReorder.push(iOrigColumn);\n        }\n      } else if (oState.order) {\n        // 1.10.1+\n        for (i = 0; i < oState.order.length; i++) {\n          oState.order[i][0] = columns[oState.order[i][0]]._ColReorder_iOrigCol;\n        }\n\n        var stateColumnsCopy = $.extend(true, [], oState.columns);\n\n        for (i = 0, iLen = columns.length; i < iLen; i++) {\n          iOrigColumn = columns[i]._ColReorder_iOrigCol;\n          /* Columns */\n\n          oState.columns[iOrigColumn] = stateColumnsCopy[i];\n          /* Column reordering */\n\n          oState.ColReorder.push(iOrigColumn);\n        }\n      }\n    },\n\n    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n     * Mouse drop and drag\n     */\n\n    /**\n     * Add a mouse down listener to a particluar TH element\n     *  @method  _fnMouseListener\n     *  @param   int i Column index\n     *  @param   element nTh TH element clicked on\n     *  @returns void\n     *  @private\n     */\n    \"_fnMouseListener\": function _fnMouseListener(i, nTh) {\n      var that = this;\n      $(nTh).on('mousedown.ColReorder', function (e) {\n        e.preventDefault();\n\n        that._fnMouseDown.call(that, e, nTh);\n      });\n    },\n\n    /**\n     * Mouse down on a TH element in the table header\n     *  @method  _fnMouseDown\n     *  @param   event e Mouse event\n     *  @param   element nTh TH element to be dragged\n     *  @returns void\n     *  @private\n     */\n    \"_fnMouseDown\": function _fnMouseDown(e, nTh) {\n      var that = this;\n      /* Store information about the mouse position */\n\n      var target = $(e.target).closest('th, td');\n      var offset = target.offset();\n      var idx = parseInt($(nTh).attr('data-column-index'), 10);\n\n      if (idx === undefined) {\n        return;\n      }\n\n      this.s.mouse.startX = e.pageX;\n      this.s.mouse.startY = e.pageY;\n      this.s.mouse.offsetX = e.pageX - offset.left;\n      this.s.mouse.offsetY = e.pageY - offset.top;\n      this.s.mouse.target = this.s.dt.aoColumns[idx].nTh; //target[0];\n\n      this.s.mouse.targetIndex = idx;\n      this.s.mouse.fromIndex = idx;\n\n      this._fnRegions();\n      /* Add event handlers to the document */\n\n\n      $(document).on('mousemove.ColReorder', function (e) {\n        that._fnMouseMove.call(that, e);\n      }).on('mouseup.ColReorder', function (e) {\n        that._fnMouseUp.call(that, e);\n      });\n    },\n\n    /**\n     * Deal with a mouse move event while dragging a node\n     *  @method  _fnMouseMove\n     *  @param   event e Mouse event\n     *  @returns void\n     *  @private\n     */\n    \"_fnMouseMove\": function _fnMouseMove(e) {\n      var that = this;\n\n      if (this.dom.drag === null) {\n        /* Only create the drag element if the mouse has moved a specific distance from the start\n         * point - this allows the user to make small mouse movements when sorting and not have a\n         * possibly confusing drag element showing up\n         */\n        if (Math.pow(Math.pow(e.pageX - this.s.mouse.startX, 2) + Math.pow(e.pageY - this.s.mouse.startY, 2), 0.5) < 5) {\n          return;\n        }\n\n        this._fnCreateDragNode();\n      }\n      /* Position the element - we respect where in the element the click occured */\n\n\n      this.dom.drag.css({\n        left: e.pageX - this.s.mouse.offsetX,\n        top: e.pageY - this.s.mouse.offsetY\n      });\n      /* Based on the current mouse position, calculate where the insert should go */\n\n      var bSet = false;\n      var lastToIndex = this.s.mouse.toIndex;\n\n      for (var i = 1, iLen = this.s.aoTargets.length; i < iLen; i++) {\n        if (e.pageX < this.s.aoTargets[i - 1].x + (this.s.aoTargets[i].x - this.s.aoTargets[i - 1].x) / 2) {\n          this.dom.pointer.css('left', this.s.aoTargets[i - 1].x);\n          this.s.mouse.toIndex = this.s.aoTargets[i - 1].to;\n          bSet = true;\n          break;\n        }\n      } // The insert element wasn't positioned in the array (less than\n      // operator), so we put it at the end\n\n\n      if (!bSet) {\n        this.dom.pointer.css('left', this.s.aoTargets[this.s.aoTargets.length - 1].x);\n        this.s.mouse.toIndex = this.s.aoTargets[this.s.aoTargets.length - 1].to;\n      } // Perform reordering if realtime updating is on and the column has moved\n\n\n      if (this.s.init.bRealtime && lastToIndex !== this.s.mouse.toIndex) {\n        this.s.dt.oInstance.fnColReorder(this.s.mouse.fromIndex, this.s.mouse.toIndex, false);\n        this.s.mouse.fromIndex = this.s.mouse.toIndex;\n\n        this._fnRegions();\n      }\n    },\n\n    /**\n     * Finish off the mouse drag and insert the column where needed\n     *  @method  _fnMouseUp\n     *  @param   event e Mouse event\n     *  @returns void\n     *  @private\n     */\n    \"_fnMouseUp\": function _fnMouseUp(e) {\n      var that = this;\n      $(document).off('mousemove.ColReorder mouseup.ColReorder');\n\n      if (this.dom.drag !== null) {\n        /* Remove the guide elements */\n        this.dom.drag.remove();\n        this.dom.pointer.remove();\n        this.dom.drag = null;\n        this.dom.pointer = null;\n        /* Actually do the reorder */\n\n        this.s.dt.oInstance.fnColReorder(this.s.mouse.fromIndex, this.s.mouse.toIndex, true);\n\n        this._fnSetColumnIndexes();\n        /* When scrolling we need to recalculate the column sizes to allow for the shift */\n\n\n        if (this.s.dt.oScroll.sX !== \"\" || this.s.dt.oScroll.sY !== \"\") {\n          this.s.dt.oInstance.fnAdjustColumnSizing(false);\n        }\n        /* Save the state */\n\n\n        this.s.dt.oInstance.oApi._fnSaveState(this.s.dt);\n\n        if (this.s.reorderCallback !== null) {\n          this.s.reorderCallback.call(this);\n        }\n      }\n    },\n\n    /**\n     * Calculate a cached array with the points of the column inserts, and the\n     * 'to' points\n     *  @method  _fnRegions\n     *  @returns void\n     *  @private\n     */\n    \"_fnRegions\": function _fnRegions() {\n      var aoColumns = this.s.dt.aoColumns;\n      this.s.aoTargets.splice(0, this.s.aoTargets.length);\n      this.s.aoTargets.push({\n        \"x\": $(this.s.dt.nTable).offset().left,\n        \"to\": 0\n      });\n      var iToPoint = 0;\n      var total = $(aoColumns[0].nTh).offset().left; // Offset of the first column\n\n      for (var i = 0, iLen = aoColumns.length; i < iLen; i++) {\n        /* For the column / header in question, we want it's position to remain the same if the\n         * position is just to it's immediate left or right, so we only increment the counter for\n         * other columns\n         */\n        if (i != this.s.mouse.fromIndex) {\n          iToPoint++;\n        }\n\n        if (aoColumns[i].bVisible) {\n          total += $(aoColumns[i].nTh).outerWidth();\n          this.s.aoTargets.push({\n            \"x\": total,\n            \"to\": iToPoint\n          });\n        }\n      }\n      /* Disallow columns for being reordered by drag and drop, counting right to left */\n\n\n      if (this.s.fixedRight !== 0) {\n        this.s.aoTargets.splice(this.s.aoTargets.length - this.s.fixedRight);\n      }\n      /* Disallow columns for being reordered by drag and drop, counting left to right */\n\n\n      if (this.s.fixed !== 0) {\n        this.s.aoTargets.splice(0, this.s.fixed);\n      }\n    },\n\n    /**\n     * Copy the TH element that is being drags so the user has the idea that they are actually\n     * moving it around the page.\n     *  @method  _fnCreateDragNode\n     *  @returns void\n     *  @private\n     */\n    \"_fnCreateDragNode\": function _fnCreateDragNode() {\n      var scrolling = this.s.dt.oScroll.sX !== \"\" || this.s.dt.oScroll.sY !== \"\";\n      var origCell = this.s.dt.aoColumns[this.s.mouse.targetIndex].nTh;\n      var origTr = origCell.parentNode;\n      var origThead = origTr.parentNode;\n      var origTable = origThead.parentNode;\n      var cloneCell = $(origCell).clone(); // This is a slightly odd combination of jQuery and DOM, but it is the\n      // fastest and least resource intensive way I could think of cloning\n      // the table with just a single header cell in it.\n\n      this.dom.drag = $(origTable.cloneNode(false)).addClass('DTCR_clonedTable').append($(origThead.cloneNode(false)).append($(origTr.cloneNode(false)).append(cloneCell[0]))).css({\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: $(origCell).outerWidth(),\n        height: $(origCell).outerHeight()\n      }).appendTo('body');\n      this.dom.pointer = $('<div></div>').addClass('DTCR_pointer').css({\n        position: 'absolute',\n        top: scrolling ? $('div.dataTables_scroll', this.s.dt.nTableWrapper).offset().top : $(this.s.dt.nTable).offset().top,\n        height: scrolling ? $('div.dataTables_scroll', this.s.dt.nTableWrapper).height() : $(this.s.dt.nTable).height()\n      }).appendTo('body');\n    },\n\n    /**\n     * Add a data attribute to the column headers, so we know the index of\n     * the row to be reordered. This allows fast detection of the index, and\n     * for this plug-in to work with FixedHeader which clones the nodes.\n     *  @private\n     */\n    \"_fnSetColumnIndexes\": function _fnSetColumnIndexes() {\n      $.each(this.s.dt.aoColumns, function (i, column) {\n        $(column.nTh).attr('data-column-index', i);\n      });\n    }\n  });\n  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n   * Static parameters\n   * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n  /**\n   * ColReorder default settings for initialisation\n   *  @namespace\n   *  @static\n   */\n\n  ColReorder.defaults = {\n    /**\n     * Predefined ordering for the columns that will be applied automatically\n     * on initialisation. If not specified then the order that the columns are\n     * found to be in the HTML is the order used.\n     *  @type array\n     *  @default null\n     *  @static\n     */\n    aiOrder: null,\n\n    /**\n     * Redraw the table's column ordering as the end user draws the column\n     * (`true`) or wait until the mouse is released (`false` - default). Note\n     * that this will perform a redraw on each reordering, which involves an\n     * Ajax request each time if you are using server-side processing in\n     * DataTables.\n     *  @type boolean\n     *  @default false\n     *  @static\n     */\n    bRealtime: true,\n\n    /**\n     * Indicate how many columns should be fixed in position (counting from the\n     * left). This will typically be 1 if used, but can be as high as you like.\n     *  @type int\n     *  @default 0\n     *  @static\n     */\n    iFixedColumnsLeft: 0,\n\n    /**\n     * As `iFixedColumnsRight` but counting from the right.\n     *  @type int\n     *  @default 0\n     *  @static\n     */\n    iFixedColumnsRight: 0,\n\n    /**\n     * Callback function that is fired when columns are reordered. The `column-\n     * reorder` event is preferred over this callback\n     *  @type function():void\n     *  @default null\n     *  @static\n     */\n    fnReorderCallback: null\n  };\n  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n   * Constants\n   * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n  /**\n   * ColReorder version\n   *  @constant  version\n   *  @type      String\n   *  @default   As code\n   */\n\n  ColReorder.version = \"1.3.0\";\n  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n   * DataTables interfaces\n   * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n  // Expose\n\n  $.fn.dataTable.ColReorder = ColReorder;\n  $.fn.DataTable.ColReorder = ColReorder; // Register a new feature with DataTables\n\n  if (typeof $.fn.dataTable == \"function\" && typeof $.fn.dataTableExt.fnVersionCheck == \"function\" && $.fn.dataTableExt.fnVersionCheck('1.10.8')) {\n    $.fn.dataTableExt.aoFeatures.push({\n      \"fnInit\": function fnInit(settings) {\n        var table = settings.oInstance;\n\n        if (!settings._colReorder) {\n          var dtInit = settings.oInit;\n          var opts = dtInit.colReorder || dtInit.oColReorder || {};\n          new ColReorder(settings, opts);\n        } else {\n          table.oApi._fnLog(settings, 1, \"ColReorder attempted to initialise twice. Ignoring second\");\n        }\n\n        return null;\n        /* No node for DataTables to insert */\n      },\n      \"cFeature\": \"R\",\n      \"sFeature\": \"ColReorder\"\n    });\n  } else {\n    alert(\"Warning: ColReorder requires DataTables 1.10.8 or greater - www.datatables.net/download\");\n  } // Attach a listener to the document which listens for DataTables initialisation\n  // events so we can automatically initialise\n\n\n  $(document).on('preInit.dt.colReorder', function (e, settings) {\n    if (e.namespace !== 'dt') {\n      return;\n    }\n\n    var init = settings.oInit.colReorder;\n    var defaults = DataTable.defaults.colReorder;\n\n    if (init || defaults) {\n      var opts = $.extend({}, init, defaults);\n\n      if (init !== false) {\n        new ColReorder(settings, opts);\n      }\n    }\n  }); // API augmentation\n\n  $.fn.dataTable.Api.register('colReorder.reset()', function () {\n    return this.iterator('table', function (ctx) {\n      ctx._colReorder.fnReset();\n    });\n  });\n  $.fn.dataTable.Api.register('colReorder.order()', function (set, original) {\n    if (set) {\n      return this.iterator('table', function (ctx) {\n        ctx._colReorder.fnOrder(set, original);\n      });\n    }\n\n    return this.context.length ? this.context[0]._colReorder.fnOrder() : null;\n  });\n  $.fn.dataTable.Api.register('colReorder.transpose()', function (idx, dir) {\n    return this.context.length && this.context[0]._colReorder ? this.context[0]._colReorder.fnTranspose(idx, dir) : idx;\n  });\n  return ColReorder;\n});","map":{"version":3,"sources":["/Users/david/Winner-Stock/app/javascript/dataTables/dataTables.colReorder.js"],"names":["factory","define","amd","$","window","document","exports","module","root","fn","dataTable","require","jQuery","undefined","DataTable","fnInvertKeyValues","aIn","aRet","i","iLen","length","fnArraySwitch","aArray","iFrom","iTo","mStore","splice","fnDomSwitch","nParent","anTags","childNodes","nodeType","push","nStore","insertBefore","appendChild","dataTableExt","oApi","fnColReorder","oSettings","drop","j","jLen","iCols","aoColumns","nTrs","oCol","attrMap","obj","prop","mapping","a","split","num","shift","isNaN","join","_fnLog","aiMapping","aiInvertMapping","aaSorting","aaSortingFixed","aDataSort","idx","each","aLastSort","val","src","mData","_fnColumnOptions","isPlainObject","bVisible","iVisibleIndex","_fnColumnIndexToVisible","iInsertBeforeIndex","nTHead","getElementsByTagName","nTFoot","aoData","nTr","aoPreSearchCols","data","anCells","isArray","_aData","aoHeader","aoFooter","api","Api","rows","invalidate","nTh","off","_fnSortAttachListener","oInstance","trigger","from","to","ColReorder","dt","opts","settings","_colReorder","camelToHungarian","defaults","s","extend","dom","_fnConstruct","prototype","_fnOrderColumns","fnOrder","set","original","ien","jen","columns","_ColReorder_iOrigCol","order","inArray","fnTranspose","dir","map","index","that","table","nTable","init","iFixedColumns","fixed","iFixedColumnsLeft","fixedRight","iFixedColumnsRight","fnReorderCallback","reorderCallback","_fnMouseListener","_fnCallbackReg","oS","oData","_fnStateSave","call","aiOrder","slice","oLoadedState","_bInitComplete","bDone","on","resort","_fnSetColumnIndexes","find","column","removeAttr","changed","currIndex","oScroll","sX","sY","fnAdjustColumnSizing","_fnSaveState","oState","aCopy","iOrigColumn","aSearchCopy","aoSearchCols","abVisCols","stateColumnsCopy","e","preventDefault","_fnMouseDown","target","closest","offset","parseInt","attr","mouse","startX","pageX","startY","pageY","offsetX","left","offsetY","top","targetIndex","fromIndex","_fnRegions","_fnMouseMove","_fnMouseUp","drag","Math","pow","_fnCreateDragNode","css","bSet","lastToIndex","toIndex","aoTargets","x","pointer","bRealtime","remove","iToPoint","total","outerWidth","scrolling","origCell","origTr","parentNode","origThead","origTable","cloneCell","clone","cloneNode","addClass","append","position","width","height","outerHeight","appendTo","nTableWrapper","version","fnVersionCheck","aoFeatures","dtInit","oInit","colReorder","oColReorder","alert","namespace","register","iterator","ctx","fnReset","context"],"mappings":"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","sourcesContent":["/*! ColReorder 1.3.0\n * Â©2010-2015 SpryMedia Ltd - datatables.net/license\n */\n\n/**\n * @summary     ColReorder\n * @description Provide the ability to reorder columns in a DataTable\n * @version     1.3.0\n * @file        dataTables.colReorder.js\n * @author      SpryMedia Ltd (www.sprymedia.co.uk)\n * @contact     www.sprymedia.co.uk/contact\n * @copyright   Copyright 2010-2014 SpryMedia Ltd.\n *\n * This source file is free software, available under the following license:\n *   MIT license - http://datatables.net/license/mit\n *\n * This source file is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.\n *\n * For details please refer to: http://www.datatables.net\n */\n(function( factory ){\n\tif ( typeof define === 'function' && define.amd ) {\n\t\t// AMD\n\t\tdefine( ['jquery', 'datatables.net'], function ( $ ) {\n\t\t\treturn factory( $, window, document );\n\t\t} );\n\t}\n\telse if ( typeof exports === 'object' ) {\n\t\t// CommonJS\n\t\tmodule.exports = function (root, $) {\n\t\t\tif ( ! root ) {\n\t\t\t\troot = window;\n\t\t\t}\n\n\t\t\tif ( ! $ || ! $.fn.dataTable ) {\n\t\t\t\t$ = require('datatables.net')(root, $).$;\n\t\t\t}\n\n\t\t\treturn factory( $, root, root.document );\n\t\t};\n\t}\n\telse {\n\t\t// Browser\n\t\tfactory( jQuery, window, document );\n\t}\n}(function( $, window, document, undefined ) {\n'use strict';\nvar DataTable = $.fn.dataTable;\n\n\n/**\n * Switch the key value pairing of an index array to be value key (i.e. the old value is now the\n * key). For example consider [ 2, 0, 1 ] this would be returned as [ 1, 2, 0 ].\n *  @method  fnInvertKeyValues\n *  @param   array aIn Array to switch around\n *  @returns array\n */\nfunction fnInvertKeyValues( aIn )\n{\n\tvar aRet=[];\n\tfor ( var i=0, iLen=aIn.length ; i<iLen ; i++ )\n\t{\n\t\taRet[ aIn[i] ] = i;\n\t}\n\treturn aRet;\n}\n\n\n/**\n * Modify an array by switching the position of two elements\n *  @method  fnArraySwitch\n *  @param   array aArray Array to consider, will be modified by reference (i.e. no return)\n *  @param   int iFrom From point\n *  @param   int iTo Insert point\n *  @returns void\n */\nfunction fnArraySwitch( aArray, iFrom, iTo )\n{\n\tvar mStore = aArray.splice( iFrom, 1 )[0];\n\taArray.splice( iTo, 0, mStore );\n}\n\n\n/**\n * Switch the positions of nodes in a parent node (note this is specifically designed for\n * table rows). Note this function considers all element nodes under the parent!\n *  @method  fnDomSwitch\n *  @param   string sTag Tag to consider\n *  @param   int iFrom Element to move\n *  @param   int Point to element the element to (before this point), can be null for append\n *  @returns void\n */\nfunction fnDomSwitch( nParent, iFrom, iTo )\n{\n\tvar anTags = [];\n\tfor ( var i=0, iLen=nParent.childNodes.length ; i<iLen ; i++ )\n\t{\n\t\tif ( nParent.childNodes[i].nodeType == 1 )\n\t\t{\n\t\t\tanTags.push( nParent.childNodes[i] );\n\t\t}\n\t}\n\tvar nStore = anTags[ iFrom ];\n\n\tif ( iTo !== null )\n\t{\n\t\tnParent.insertBefore( nStore, anTags[iTo] );\n\t}\n\telse\n\t{\n\t\tnParent.appendChild( nStore );\n\t}\n}\n\n\n/**\n * Plug-in for DataTables which will reorder the internal column structure by taking the column\n * from one position (iFrom) and insert it into a given point (iTo).\n *  @method  $.fn.dataTableExt.oApi.fnColReorder\n *  @param   object oSettings DataTables settings object - automatically added by DataTables!\n *  @param   int iFrom Take the column to be repositioned from this point\n *  @param   int iTo and insert it into this point\n *  @param   bool drop Indicate if the reorder is the final one (i.e. a drop)\n *    not a live reorder\n *  @returns void\n */\n$.fn.dataTableExt.oApi.fnColReorder = function ( oSettings, iFrom, iTo, drop )\n{\n\tvar i, iLen, j, jLen, iCols=oSettings.aoColumns.length, nTrs, oCol;\n\tvar attrMap = function ( obj, prop, mapping ) {\n\t\tif ( ! obj[ prop ] || typeof obj[ prop ] === 'function' ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar a = obj[ prop ].split('.');\n\t\tvar num = a.shift();\n\n\t\tif ( isNaN( num*1 ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tobj[ prop ] = mapping[ num*1 ]+'.'+a.join('.');\n\t};\n\n\t/* Sanity check in the input */\n\tif ( iFrom == iTo )\n\t{\n\t\t/* Pointless reorder */\n\t\treturn;\n\t}\n\n\tif ( iFrom < 0 || iFrom >= iCols )\n\t{\n\t\tthis.oApi._fnLog( oSettings, 1, \"ColReorder 'from' index is out of bounds: \"+iFrom );\n\t\treturn;\n\t}\n\n\tif ( iTo < 0 || iTo >= iCols )\n\t{\n\t\tthis.oApi._fnLog( oSettings, 1, \"ColReorder 'to' index is out of bounds: \"+iTo );\n\t\treturn;\n\t}\n\n\t/*\n\t * Calculate the new column array index, so we have a mapping between the old and new\n\t */\n\tvar aiMapping = [];\n\tfor ( i=0, iLen=iCols ; i<iLen ; i++ )\n\t{\n\t\taiMapping[i] = i;\n\t}\n\tfnArraySwitch( aiMapping, iFrom, iTo );\n\tvar aiInvertMapping = fnInvertKeyValues( aiMapping );\n\n\n\t/*\n\t * Convert all internal indexing to the new column order indexes\n\t */\n\t/* Sorting */\n\tfor ( i=0, iLen=oSettings.aaSorting.length ; i<iLen ; i++ )\n\t{\n\t\toSettings.aaSorting[i][0] = aiInvertMapping[ oSettings.aaSorting[i][0] ];\n\t}\n\n\t/* Fixed sorting */\n\tif ( oSettings.aaSortingFixed !== null )\n\t{\n\t\tfor ( i=0, iLen=oSettings.aaSortingFixed.length ; i<iLen ; i++ )\n\t\t{\n\t\t\toSettings.aaSortingFixed[i][0] = aiInvertMapping[ oSettings.aaSortingFixed[i][0] ];\n\t\t}\n\t}\n\n\t/* Data column sorting (the column which the sort for a given column should take place on) */\n\tfor ( i=0, iLen=iCols ; i<iLen ; i++ )\n\t{\n\t\toCol = oSettings.aoColumns[i];\n\t\tfor ( j=0, jLen=oCol.aDataSort.length ; j<jLen ; j++ )\n\t\t{\n\t\t\toCol.aDataSort[j] = aiInvertMapping[ oCol.aDataSort[j] ];\n\t\t}\n\n\t\t// Update the column indexes\n\t\toCol.idx = aiInvertMapping[ oCol.idx ];\n\t}\n\n\t// Update 1.10 optimised sort class removal variable\n\t$.each( oSettings.aLastSort, function (i, val) {\n\t\toSettings.aLastSort[i].src = aiInvertMapping[ val.src ];\n\t} );\n\n\t/* Update the Get and Set functions for each column */\n\tfor ( i=0, iLen=iCols ; i<iLen ; i++ )\n\t{\n\t\toCol = oSettings.aoColumns[i];\n\n\t\tif ( typeof oCol.mData == 'number' ) {\n\t\t\toCol.mData = aiInvertMapping[ oCol.mData ];\n\n\t\t\t// regenerate the get / set functions\n\t\t\toSettings.oApi._fnColumnOptions( oSettings, i, {} );\n\t\t}\n\t\telse if ( $.isPlainObject( oCol.mData ) ) {\n\t\t\t// HTML5 data sourced\n\t\t\tattrMap( oCol.mData, '_',      aiInvertMapping );\n\t\t\tattrMap( oCol.mData, 'filter', aiInvertMapping );\n\t\t\tattrMap( oCol.mData, 'sort',   aiInvertMapping );\n\t\t\tattrMap( oCol.mData, 'type',   aiInvertMapping );\n\n\t\t\t// regenerate the get / set functions\n\t\t\toSettings.oApi._fnColumnOptions( oSettings, i, {} );\n\t\t}\n\t}\n\n\n\t/*\n\t * Move the DOM elements\n\t */\n\tif ( oSettings.aoColumns[iFrom].bVisible )\n\t{\n\t\t/* Calculate the current visible index and the point to insert the node before. The insert\n\t\t * before needs to take into account that there might not be an element to insert before,\n\t\t * in which case it will be null, and an appendChild should be used\n\t\t */\n\t\tvar iVisibleIndex = this.oApi._fnColumnIndexToVisible( oSettings, iFrom );\n\t\tvar iInsertBeforeIndex = null;\n\n\t\ti = iTo < iFrom ? iTo : iTo + 1;\n\t\twhile ( iInsertBeforeIndex === null && i < iCols )\n\t\t{\n\t\t\tiInsertBeforeIndex = this.oApi._fnColumnIndexToVisible( oSettings, i );\n\t\t\ti++;\n\t\t}\n\n\t\t/* Header */\n\t\tnTrs = oSettings.nTHead.getElementsByTagName('tr');\n\t\tfor ( i=0, iLen=nTrs.length ; i<iLen ; i++ )\n\t\t{\n\t\t\tfnDomSwitch( nTrs[i], iVisibleIndex, iInsertBeforeIndex );\n\t\t}\n\n\t\t/* Footer */\n\t\tif ( oSettings.nTFoot !== null )\n\t\t{\n\t\t\tnTrs = oSettings.nTFoot.getElementsByTagName('tr');\n\t\t\tfor ( i=0, iLen=nTrs.length ; i<iLen ; i++ )\n\t\t\t{\n\t\t\t\tfnDomSwitch( nTrs[i], iVisibleIndex, iInsertBeforeIndex );\n\t\t\t}\n\t\t}\n\n\t\t/* Body */\n\t\tfor ( i=0, iLen=oSettings.aoData.length ; i<iLen ; i++ )\n\t\t{\n\t\t\tif ( oSettings.aoData[i].nTr !== null )\n\t\t\t{\n\t\t\t\tfnDomSwitch( oSettings.aoData[i].nTr, iVisibleIndex, iInsertBeforeIndex );\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Move the internal array elements\n\t */\n\t/* Columns */\n\tfnArraySwitch( oSettings.aoColumns, iFrom, iTo );\n\n\t/* Search columns */\n\tfnArraySwitch( oSettings.aoPreSearchCols, iFrom, iTo );\n\n\t/* Array array - internal data anodes cache */\n\tfor ( i=0, iLen=oSettings.aoData.length ; i<iLen ; i++ )\n\t{\n\t\tvar data = oSettings.aoData[i];\n\n\t\tif ( data.anCells ) {\n\t\t\tfnArraySwitch( data.anCells, iFrom, iTo );\n\t\t}\n\n\t\t// For DOM sourced data, the invalidate will reread the cell into\n\t\t// the data array, but for data sources as an array, they need to\n\t\t// be flipped\n\t\tif ( data.src !== 'dom' && $.isArray( data._aData ) ) {\n\t\t\tfnArraySwitch( data._aData, iFrom, iTo );\n\t\t}\n\t}\n\n\t/* Reposition the header elements in the header layout array */\n\tfor ( i=0, iLen=oSettings.aoHeader.length ; i<iLen ; i++ )\n\t{\n\t\tfnArraySwitch( oSettings.aoHeader[i], iFrom, iTo );\n\t}\n\n\tif ( oSettings.aoFooter !== null )\n\t{\n\t\tfor ( i=0, iLen=oSettings.aoFooter.length ; i<iLen ; i++ )\n\t\t{\n\t\t\tfnArraySwitch( oSettings.aoFooter[i], iFrom, iTo );\n\t\t}\n\t}\n\n\t// Invalidate row cached data for sorting, filtering etc\n\tvar api = new $.fn.dataTable.Api( oSettings );\n\tapi.rows().invalidate();\n\n\t/*\n\t * Update DataTables' event handlers\n\t */\n\n\t/* Sort listener */\n\tfor ( i=0, iLen=iCols ; i<iLen ; i++ )\n\t{\n\t\t$(oSettings.aoColumns[i].nTh).off('click.DT');\n\t\tthis.oApi._fnSortAttachListener( oSettings, oSettings.aoColumns[i].nTh, i );\n\t}\n\n\n\t/* Fire an event so other plug-ins can update */\n\t$(oSettings.oInstance).trigger( 'column-reorder.dt', [ oSettings, {\n\t\tfrom: iFrom,\n\t\tto: iTo,\n\t\tmapping: aiInvertMapping,\n\t\tdrop: drop,\n\n\t\t// Old style parameters for compatibility\n\t\tiFrom: iFrom,\n\t\tiTo: iTo,\n\t\taiInvertMapping: aiInvertMapping\n\t} ] );\n};\n\n\n/**\n * ColReorder provides column visibility control for DataTables\n * @class ColReorder\n * @constructor\n * @param {object} dt DataTables settings object\n * @param {object} opts ColReorder options\n */\nvar ColReorder = function( dt, opts )\n{\n\tvar settings = new $.fn.dataTable.Api( dt ).settings()[0];\n\n\t// Ensure that we can't initialise on the same table twice\n\tif ( settings._colReorder ) {\n\t\treturn settings._colReorder;\n\t}\n\n\t// Allow the options to be a boolean for defaults\n\tif ( opts === true ) {\n\t\topts = {};\n\t}\n\n\t// Convert from camelCase to Hungarian, just as DataTables does\n\tvar camelToHungarian = $.fn.dataTable.camelToHungarian;\n\tif ( camelToHungarian ) {\n\t\tcamelToHungarian( ColReorder.defaults, ColReorder.defaults, true );\n\t\tcamelToHungarian( ColReorder.defaults, opts || {} );\n\t}\n\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Public class variables\n\t * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\t/**\n\t * @namespace Settings object which contains customisable information for ColReorder instance\n\t */\n\tthis.s = {\n\t\t/**\n\t\t * DataTables settings object\n\t\t *  @property dt\n\t\t *  @type     Object\n\t\t *  @default  null\n\t\t */\n\t\t\"dt\": null,\n\n\t\t/**\n\t\t * Initialisation object used for this instance\n\t\t *  @property init\n\t\t *  @type     object\n\t\t *  @default  {}\n\t\t */\n\t\t\"init\": $.extend( true, {}, ColReorder.defaults, opts ),\n\n\t\t/**\n\t\t * Number of columns to fix (not allow to be reordered)\n\t\t *  @property fixed\n\t\t *  @type     int\n\t\t *  @default  0\n\t\t */\n\t\t\"fixed\": 0,\n\n\t\t/**\n\t\t * Number of columns to fix counting from right (not allow to be reordered)\n\t\t *  @property fixedRight\n\t\t *  @type     int\n\t\t *  @default  0\n\t\t */\n\t\t\"fixedRight\": 0,\n\n\t\t/**\n\t\t * Callback function for once the reorder has been done\n\t\t *  @property reorderCallback\n\t\t *  @type     function\n\t\t *  @default  null\n\t\t */\n\t\t\"reorderCallback\": null,\n\n\t\t/**\n\t\t * @namespace Information used for the mouse drag\n\t\t */\n\t\t\"mouse\": {\n\t\t\t\"startX\": -1,\n\t\t\t\"startY\": -1,\n\t\t\t\"offsetX\": -1,\n\t\t\t\"offsetY\": -1,\n\t\t\t\"target\": -1,\n\t\t\t\"targetIndex\": -1,\n\t\t\t\"fromIndex\": -1\n\t\t},\n\n\t\t/**\n\t\t * Information which is used for positioning the insert cusor and knowing where to do the\n\t\t * insert. Array of objects with the properties:\n\t\t *   x: x-axis position\n\t\t *   to: insert point\n\t\t *  @property aoTargets\n\t\t *  @type     array\n\t\t *  @default  []\n\t\t */\n\t\t\"aoTargets\": []\n\t};\n\n\n\t/**\n\t * @namespace Common and useful DOM elements for the class instance\n\t */\n\tthis.dom = {\n\t\t/**\n\t\t * Dragging element (the one the mouse is moving)\n\t\t *  @property drag\n\t\t *  @type     element\n\t\t *  @default  null\n\t\t */\n\t\t\"drag\": null,\n\n\t\t/**\n\t\t * The insert cursor\n\t\t *  @property pointer\n\t\t *  @type     element\n\t\t *  @default  null\n\t\t */\n\t\t\"pointer\": null\n\t};\n\n\n\t/* Constructor logic */\n\tthis.s.dt = settings;\n\tthis.s.dt._colReorder = this;\n\tthis._fnConstruct();\n\n\treturn this;\n};\n\n\n\n$.extend( ColReorder.prototype, {\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Public methods\n\t * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\t/**\n\t * Reset the column ordering to the original ordering that was detected on\n\t * start up.\n\t *  @return {this} Returns `this` for chaining.\n\t *\n\t *  @example\n\t *    // DataTables initialisation with ColReorder\n\t *    var table = $('#example').dataTable( {\n\t *        \"sDom\": 'Rlfrtip'\n\t *    } );\n\t *\n\t *    // Add click event to a button to reset the ordering\n\t *    $('#resetOrdering').click( function (e) {\n\t *        e.preventDefault();\n\t *        $.fn.dataTable.ColReorder( table ).fnReset();\n\t *    } );\n\t */\n\t\"fnReset\": function ()\n\t{\n\t\tthis._fnOrderColumns( this.fnOrder() );\n\n\t\treturn this;\n\t},\n\n\t/**\n\t * `Deprecated` - Get the current order of the columns, as an array.\n\t *  @return {array} Array of column identifiers\n\t *  @deprecated `fnOrder` should be used in preference to this method.\n\t *      `fnOrder` acts as a getter/setter.\n\t */\n\t\"fnGetCurrentOrder\": function ()\n\t{\n\t\treturn this.fnOrder();\n\t},\n\n\t/**\n\t * Get the current order of the columns, as an array. Note that the values\n\t * given in the array are unique identifiers for each column. Currently\n\t * these are the original ordering of the columns that was detected on\n\t * start up, but this could potentially change in future.\n\t *  @return {array} Array of column identifiers\n\t *\n\t *  @example\n\t *    // Get column ordering for the table\n\t *    var order = $.fn.dataTable.ColReorder( dataTable ).fnOrder();\n\t *//**\n\t * Set the order of the columns, from the positions identified in the\n\t * ordering array given. Note that ColReorder takes a brute force approach\n\t * to reordering, so it is possible multiple reordering events will occur\n\t * before the final order is settled upon.\n\t *  @param {array} [set] Array of column identifiers in the new order. Note\n\t *    that every column must be included, uniquely, in this array.\n\t *  @return {this} Returns `this` for chaining.\n\t *\n\t *  @example\n\t *    // Swap the first and second columns\n\t *    $.fn.dataTable.ColReorder( dataTable ).fnOrder( [1, 0, 2, 3, 4] );\n\t *\n\t *  @example\n\t *    // Move the first column to the end for the table `#example`\n\t *    var curr = $.fn.dataTable.ColReorder( '#example' ).fnOrder();\n\t *    var first = curr.shift();\n\t *    curr.push( first );\n\t *    $.fn.dataTable.ColReorder( '#example' ).fnOrder( curr );\n\t *\n\t *  @example\n\t *    // Reverse the table's order\n\t *    $.fn.dataTable.ColReorder( '#example' ).fnOrder(\n\t *      $.fn.dataTable.ColReorder( '#example' ).fnOrder().reverse()\n\t *    );\n\t */\n\t\"fnOrder\": function ( set, original )\n\t{\n\t\tvar a = [], i, ien, j, jen;\n\t\tvar columns = this.s.dt.aoColumns;\n\n\t\tif ( set === undefined ){\n\t\t\tfor ( i=0, ien=columns.length ; i<ien ; i++ ) {\n\t\t\t\ta.push( columns[i]._ColReorder_iOrigCol );\n\t\t\t}\n\n\t\t\treturn a;\n\t\t}\n\n\t\t// The order given is based on the original indexes, rather than the\n\t\t// existing ones, so we need to translate from the original to current\n\t\t// before then doing the order\n\t\tif ( original ) {\n\t\t\tvar order = this.fnOrder();\n\n\t\t\tfor ( i=0, ien=set.length ; i<ien ; i++ ) {\n\t\t\t\ta.push( $.inArray( set[i], order ) );\n\t\t\t}\n\n\t\t\tset = a;\n\t\t}\n\n\t\tthis._fnOrderColumns( fnInvertKeyValues( set ) );\n\n\t\treturn this;\n\t},\n\n\n\t/**\n\t * Convert from the original column index, to the original\n\t *\n\t * @param  {int|array} idx Index(es) to convert\n\t * @param  {string} dir Transpose direction - `fromOriginal` / `toCurrent`\n\t *   or `'toOriginal` / `fromCurrent`\n\t * @return {int|array}     Converted values\n\t */\n\tfnTranspose: function ( idx, dir )\n\t{\n\t\tif ( ! dir ) {\n\t\t\tdir = 'toCurrent';\n\t\t}\n\n\t\tvar order = this.fnOrder();\n\t\tvar columns = this.s.dt.aoColumns;\n\n\t\tif ( dir === 'toCurrent' ) {\n\t\t\t// Given an original index, want the current\n\t\t\treturn ! $.isArray( idx ) ?\n\t\t\t\t$.inArray( idx, order ) :\n\t\t\t\t$.map( idx, function ( index ) {\n\t\t\t\t\treturn $.inArray( index, order );\n\t\t\t\t} );\n\t\t}\n\t\telse {\n\t\t\t// Given a current index, want the original\n\t\t\treturn ! $.isArray( idx ) ?\n\t\t\t\tcolumns[idx]._ColReorder_iOrigCol :\n\t\t\t\t$.map( idx, function ( index ) {\n\t\t\t\t\treturn columns[index]._ColReorder_iOrigCol;\n\t\t\t\t} );\n\t\t}\n\t},\n\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Private methods (they are of course public in JS, but recommended as private)\n\t * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\t/**\n\t * Constructor logic\n\t *  @method  _fnConstruct\n\t *  @returns void\n\t *  @private\n\t */\n\t\"_fnConstruct\": function ()\n\t{\n\t\tvar that = this;\n\t\tvar iLen = this.s.dt.aoColumns.length;\n\t\tvar table = this.s.dt.nTable;\n\t\tvar i;\n\n\t\t/* Columns discounted from reordering - counting left to right */\n\t\tif ( this.s.init.iFixedColumns )\n\t\t{\n\t\t\tthis.s.fixed = this.s.init.iFixedColumns;\n\t\t}\n\n\t\tif ( this.s.init.iFixedColumnsLeft )\n\t\t{\n\t\t\tthis.s.fixed = this.s.init.iFixedColumnsLeft;\n\t\t}\n\n\t\t/* Columns discounted from reordering - counting right to left */\n\t\tthis.s.fixedRight = this.s.init.iFixedColumnsRight ?\n\t\t\tthis.s.init.iFixedColumnsRight :\n\t\t\t0;\n\n\t\t/* Drop callback initialisation option */\n\t\tif ( this.s.init.fnReorderCallback )\n\t\t{\n\t\t\tthis.s.reorderCallback = this.s.init.fnReorderCallback;\n\t\t}\n\n\t\t/* Add event handlers for the drag and drop, and also mark the original column order */\n\t\tfor ( i = 0; i < iLen; i++ )\n\t\t{\n\t\t\tif ( i > this.s.fixed-1 && i < iLen - this.s.fixedRight )\n\t\t\t{\n\t\t\t\tthis._fnMouseListener( i, this.s.dt.aoColumns[i].nTh );\n\t\t\t}\n\n\t\t\t/* Mark the original column order for later reference */\n\t\t\tthis.s.dt.aoColumns[i]._ColReorder_iOrigCol = i;\n\t\t}\n\n\t\t/* State saving */\n\t\tthis.s.dt.oApi._fnCallbackReg( this.s.dt, 'aoStateSaveParams', function (oS, oData) {\n\t\t\tthat._fnStateSave.call( that, oData );\n\t\t}, \"ColReorder_State\" );\n\n\t\t/* An initial column order has been specified */\n\t\tvar aiOrder = null;\n\t\tif ( this.s.init.aiOrder )\n\t\t{\n\t\t\taiOrder = this.s.init.aiOrder.slice();\n\t\t}\n\n\t\t/* State loading, overrides the column order given */\n\t\tif ( this.s.dt.oLoadedState && typeof this.s.dt.oLoadedState.ColReorder != 'undefined' &&\n\t\t  this.s.dt.oLoadedState.ColReorder.length == this.s.dt.aoColumns.length )\n\t\t{\n\t\t\taiOrder = this.s.dt.oLoadedState.ColReorder;\n\t\t}\n\n\t\t/* If we have an order to apply - do so */\n\t\tif ( aiOrder )\n\t\t{\n\t\t\t/* We might be called during or after the DataTables initialisation. If before, then we need\n\t\t\t * to wait until the draw is done, if after, then do what we need to do right away\n\t\t\t */\n\t\t\tif ( !that.s.dt._bInitComplete )\n\t\t\t{\n\t\t\t\tvar bDone = false;\n\t\t\t\t$(table).on( 'draw.dt.colReorder', function () {\n\t\t\t\t\tif ( !that.s.dt._bInitComplete && !bDone )\n\t\t\t\t\t{\n\t\t\t\t\t\tbDone = true;\n\t\t\t\t\t\tvar resort = fnInvertKeyValues( aiOrder );\n\t\t\t\t\t\tthat._fnOrderColumns.call( that, resort );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar resort = fnInvertKeyValues( aiOrder );\n\t\t\t\tthat._fnOrderColumns.call( that, resort );\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis._fnSetColumnIndexes();\n\t\t}\n\n\t\t// Destroy clean up\n\t\t$(table).on( 'destroy.dt.colReorder', function () {\n\t\t\t$(table).off( 'destroy.dt.colReorder draw.dt.colReorder' );\n\t\t\t$(that.s.dt.nTHead).find( '*' ).off( '.ColReorder' );\n\n\t\t\t$.each( that.s.dt.aoColumns, function (i, column) {\n\t\t\t\t$(column.nTh).removeAttr('data-column-index');\n\t\t\t} );\n\n\t\t\tthat.s.dt._colReorder = null;\n\t\t\tthat.s = null;\n\t\t} );\n\t},\n\n\n\t/**\n\t * Set the column order from an array\n\t *  @method  _fnOrderColumns\n\t *  @param   array a An array of integers which dictate the column order that should be applied\n\t *  @returns void\n\t *  @private\n\t */\n\t\"_fnOrderColumns\": function ( a )\n\t{\n\t\tvar changed = false;\n\n\t\tif ( a.length != this.s.dt.aoColumns.length )\n\t\t{\n\t\t\tthis.s.dt.oInstance.oApi._fnLog( this.s.dt, 1, \"ColReorder - array reorder does not \"+\n\t\t\t\t\"match known number of columns. Skipping.\" );\n\t\t\treturn;\n\t\t}\n\n\t\tfor ( var i=0, iLen=a.length ; i<iLen ; i++ )\n\t\t{\n\t\t\tvar currIndex = $.inArray( i, a );\n\t\t\tif ( i != currIndex )\n\t\t\t{\n\t\t\t\t/* Reorder our switching array */\n\t\t\t\tfnArraySwitch( a, currIndex, i );\n\n\t\t\t\t/* Do the column reorder in the table */\n\t\t\t\tthis.s.dt.oInstance.fnColReorder( currIndex, i, true );\n\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\n\t\tthis._fnSetColumnIndexes();\n\n\t\t// Has anything actually changed? If not, then nothing else to do\n\t\tif ( ! changed ) {\n\t\t\treturn;\n\t\t}\n\n\t\t/* When scrolling we need to recalculate the column sizes to allow for the shift */\n\t\tif ( this.s.dt.oScroll.sX !== \"\" || this.s.dt.oScroll.sY !== \"\" )\n\t\t{\n\t\t\tthis.s.dt.oInstance.fnAdjustColumnSizing( false );\n\t\t}\n\n\t\t/* Save the state */\n\t\tthis.s.dt.oInstance.oApi._fnSaveState( this.s.dt );\n\t\t\n\t\tif ( this.s.reorderCallback !== null )\n\t\t{\n\t\t\tthis.s.reorderCallback.call( this );\n\t\t}\n\t},\n\n\n\t/**\n\t * Because we change the indexes of columns in the table, relative to their starting point\n\t * we need to reorder the state columns to what they are at the starting point so we can\n\t * then rearrange them again on state load!\n\t *  @method  _fnStateSave\n\t *  @param   object oState DataTables state\n\t *  @returns string JSON encoded cookie string for DataTables\n\t *  @private\n\t */\n\t\"_fnStateSave\": function ( oState )\n\t{\n\t\tvar i, iLen, aCopy, iOrigColumn;\n\t\tvar oSettings = this.s.dt;\n\t\tvar columns = oSettings.aoColumns;\n\n\t\toState.ColReorder = [];\n\n\t\t/* Sorting */\n\t\tif ( oState.aaSorting ) {\n\t\t\t// 1.10.0-\n\t\t\tfor ( i=0 ; i<oState.aaSorting.length ; i++ ) {\n\t\t\t\toState.aaSorting[i][0] = columns[ oState.aaSorting[i][0] ]._ColReorder_iOrigCol;\n\t\t\t}\n\n\t\t\tvar aSearchCopy = $.extend( true, [], oState.aoSearchCols );\n\n\t\t\tfor ( i=0, iLen=columns.length ; i<iLen ; i++ )\n\t\t\t{\n\t\t\t\tiOrigColumn = columns[i]._ColReorder_iOrigCol;\n\n\t\t\t\t/* Column filter */\n\t\t\t\toState.aoSearchCols[ iOrigColumn ] = aSearchCopy[i];\n\n\t\t\t\t/* Visibility */\n\t\t\t\toState.abVisCols[ iOrigColumn ] = columns[i].bVisible;\n\n\t\t\t\t/* Column reordering */\n\t\t\t\toState.ColReorder.push( iOrigColumn );\n\t\t\t}\n\t\t}\n\t\telse if ( oState.order ) {\n\t\t\t// 1.10.1+\n\t\t\tfor ( i=0 ; i<oState.order.length ; i++ ) {\n\t\t\t\toState.order[i][0] = columns[ oState.order[i][0] ]._ColReorder_iOrigCol;\n\t\t\t}\n\n\t\t\tvar stateColumnsCopy = $.extend( true, [], oState.columns );\n\n\t\t\tfor ( i=0, iLen=columns.length ; i<iLen ; i++ )\n\t\t\t{\n\t\t\t\tiOrigColumn = columns[i]._ColReorder_iOrigCol;\n\n\t\t\t\t/* Columns */\n\t\t\t\toState.columns[ iOrigColumn ] = stateColumnsCopy[i];\n\n\t\t\t\t/* Column reordering */\n\t\t\t\toState.ColReorder.push( iOrigColumn );\n\t\t\t}\n\t\t}\n\t},\n\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Mouse drop and drag\n\t */\n\n\t/**\n\t * Add a mouse down listener to a particluar TH element\n\t *  @method  _fnMouseListener\n\t *  @param   int i Column index\n\t *  @param   element nTh TH element clicked on\n\t *  @returns void\n\t *  @private\n\t */\n\t\"_fnMouseListener\": function ( i, nTh )\n\t{\n\t\tvar that = this;\n\t\t$(nTh).on( 'mousedown.ColReorder', function (e) {\n\t\t\te.preventDefault();\n\t\t\tthat._fnMouseDown.call( that, e, nTh );\n\t\t} );\n\t},\n\n\n\t/**\n\t * Mouse down on a TH element in the table header\n\t *  @method  _fnMouseDown\n\t *  @param   event e Mouse event\n\t *  @param   element nTh TH element to be dragged\n\t *  @returns void\n\t *  @private\n\t */\n\t\"_fnMouseDown\": function ( e, nTh )\n\t{\n\t\tvar that = this;\n\n\t\t/* Store information about the mouse position */\n\t\tvar target = $(e.target).closest('th, td');\n\t\tvar offset = target.offset();\n\t\tvar idx = parseInt( $(nTh).attr('data-column-index'), 10 );\n\n\t\tif ( idx === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.s.mouse.startX = e.pageX;\n\t\tthis.s.mouse.startY = e.pageY;\n\t\tthis.s.mouse.offsetX = e.pageX - offset.left;\n\t\tthis.s.mouse.offsetY = e.pageY - offset.top;\n\t\tthis.s.mouse.target = this.s.dt.aoColumns[ idx ].nTh;//target[0];\n\t\tthis.s.mouse.targetIndex = idx;\n\t\tthis.s.mouse.fromIndex = idx;\n\n\t\tthis._fnRegions();\n\n\t\t/* Add event handlers to the document */\n\t\t$(document)\n\t\t\t.on( 'mousemove.ColReorder', function (e) {\n\t\t\t\tthat._fnMouseMove.call( that, e );\n\t\t\t} )\n\t\t\t.on( 'mouseup.ColReorder', function (e) {\n\t\t\t\tthat._fnMouseUp.call( that, e );\n\t\t\t} );\n\t},\n\n\n\t/**\n\t * Deal with a mouse move event while dragging a node\n\t *  @method  _fnMouseMove\n\t *  @param   event e Mouse event\n\t *  @returns void\n\t *  @private\n\t */\n\t\"_fnMouseMove\": function ( e )\n\t{\n\t\tvar that = this;\n\n\t\tif ( this.dom.drag === null )\n\t\t{\n\t\t\t/* Only create the drag element if the mouse has moved a specific distance from the start\n\t\t\t * point - this allows the user to make small mouse movements when sorting and not have a\n\t\t\t * possibly confusing drag element showing up\n\t\t\t */\n\t\t\tif ( Math.pow(\n\t\t\t\tMath.pow(e.pageX - this.s.mouse.startX, 2) +\n\t\t\t\tMath.pow(e.pageY - this.s.mouse.startY, 2), 0.5 ) < 5 )\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._fnCreateDragNode();\n\t\t}\n\n\t\t/* Position the element - we respect where in the element the click occured */\n\t\tthis.dom.drag.css( {\n\t\t\tleft: e.pageX - this.s.mouse.offsetX,\n\t\t\ttop: e.pageY - this.s.mouse.offsetY\n\t\t} );\n\n\t\t/* Based on the current mouse position, calculate where the insert should go */\n\t\tvar bSet = false;\n\t\tvar lastToIndex = this.s.mouse.toIndex;\n\n\t\tfor ( var i=1, iLen=this.s.aoTargets.length ; i<iLen ; i++ )\n\t\t{\n\t\t\tif ( e.pageX < this.s.aoTargets[i-1].x + ((this.s.aoTargets[i].x-this.s.aoTargets[i-1].x)/2) )\n\t\t\t{\n\t\t\t\tthis.dom.pointer.css( 'left', this.s.aoTargets[i-1].x );\n\t\t\t\tthis.s.mouse.toIndex = this.s.aoTargets[i-1].to;\n\t\t\t\tbSet = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// The insert element wasn't positioned in the array (less than\n\t\t// operator), so we put it at the end\n\t\tif ( !bSet )\n\t\t{\n\t\t\tthis.dom.pointer.css( 'left', this.s.aoTargets[this.s.aoTargets.length-1].x );\n\t\t\tthis.s.mouse.toIndex = this.s.aoTargets[this.s.aoTargets.length-1].to;\n\t\t}\n\n\t\t// Perform reordering if realtime updating is on and the column has moved\n\t\tif ( this.s.init.bRealtime && lastToIndex !== this.s.mouse.toIndex ) {\n\t\t\tthis.s.dt.oInstance.fnColReorder( this.s.mouse.fromIndex, this.s.mouse.toIndex, false );\n\t\t\tthis.s.mouse.fromIndex = this.s.mouse.toIndex;\n\t\t\tthis._fnRegions();\n\t\t}\n\t},\n\n\n\t/**\n\t * Finish off the mouse drag and insert the column where needed\n\t *  @method  _fnMouseUp\n\t *  @param   event e Mouse event\n\t *  @returns void\n\t *  @private\n\t */\n\t\"_fnMouseUp\": function ( e )\n\t{\n\t\tvar that = this;\n\n\t\t$(document).off( 'mousemove.ColReorder mouseup.ColReorder' );\n\n\t\tif ( this.dom.drag !== null )\n\t\t{\n\t\t\t/* Remove the guide elements */\n\t\t\tthis.dom.drag.remove();\n\t\t\tthis.dom.pointer.remove();\n\t\t\tthis.dom.drag = null;\n\t\t\tthis.dom.pointer = null;\n\n\t\t\t/* Actually do the reorder */\n\t\t\tthis.s.dt.oInstance.fnColReorder( this.s.mouse.fromIndex, this.s.mouse.toIndex, true );\n\t\t\tthis._fnSetColumnIndexes();\n\n\t\t\t/* When scrolling we need to recalculate the column sizes to allow for the shift */\n\t\t\tif ( this.s.dt.oScroll.sX !== \"\" || this.s.dt.oScroll.sY !== \"\" )\n\t\t\t{\n\t\t\t\tthis.s.dt.oInstance.fnAdjustColumnSizing( false );\n\t\t\t}\n\n\t\t\t/* Save the state */\n\t\t\tthis.s.dt.oInstance.oApi._fnSaveState( this.s.dt );\n\n\t\t\tif ( this.s.reorderCallback !== null )\n\t\t\t{\n\t\t\t\tthis.s.reorderCallback.call( this );\n\t\t\t}\n\t\t}\n\t},\n\n\n\t/**\n\t * Calculate a cached array with the points of the column inserts, and the\n\t * 'to' points\n\t *  @method  _fnRegions\n\t *  @returns void\n\t *  @private\n\t */\n\t\"_fnRegions\": function ()\n\t{\n\t\tvar aoColumns = this.s.dt.aoColumns;\n\n\t\tthis.s.aoTargets.splice( 0, this.s.aoTargets.length );\n\n\t\tthis.s.aoTargets.push( {\n\t\t\t\"x\":  $(this.s.dt.nTable).offset().left,\n\t\t\t\"to\": 0\n\t\t} );\n\n\t\tvar iToPoint = 0;\n\t\tvar total = $(aoColumns[0].nTh).offset().left; // Offset of the first column\n\n\t\tfor ( var i=0, iLen=aoColumns.length ; i<iLen ; i++ )\n\t\t{\n\t\t\t/* For the column / header in question, we want it's position to remain the same if the\n\t\t\t * position is just to it's immediate left or right, so we only increment the counter for\n\t\t\t * other columns\n\t\t\t */\n\t\t\tif ( i != this.s.mouse.fromIndex )\n\t\t\t{\n\t\t\t\tiToPoint++;\n\t\t\t}\n\n\t\t\tif ( aoColumns[i].bVisible )\n\t\t\t{\n\t\t\t\ttotal += $(aoColumns[i].nTh).outerWidth();\n\n\t\t\t\tthis.s.aoTargets.push( {\n\t\t\t\t\t\"x\":  total,\n\t\t\t\t\t\"to\": iToPoint\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\t/* Disallow columns for being reordered by drag and drop, counting right to left */\n\t\tif ( this.s.fixedRight !== 0 )\n\t\t{\n\t\t\tthis.s.aoTargets.splice( this.s.aoTargets.length - this.s.fixedRight );\n\t\t}\n\n\t\t/* Disallow columns for being reordered by drag and drop, counting left to right */\n\t\tif ( this.s.fixed !== 0 )\n\t\t{\n\t\t\tthis.s.aoTargets.splice( 0, this.s.fixed );\n\t\t}\n\t},\n\n\n\t/**\n\t * Copy the TH element that is being drags so the user has the idea that they are actually\n\t * moving it around the page.\n\t *  @method  _fnCreateDragNode\n\t *  @returns void\n\t *  @private\n\t */\n\t\"_fnCreateDragNode\": function ()\n\t{\n\t\tvar scrolling = this.s.dt.oScroll.sX !== \"\" || this.s.dt.oScroll.sY !== \"\";\n\n\t\tvar origCell = this.s.dt.aoColumns[ this.s.mouse.targetIndex ].nTh;\n\t\tvar origTr = origCell.parentNode;\n\t\tvar origThead = origTr.parentNode;\n\t\tvar origTable = origThead.parentNode;\n\t\tvar cloneCell = $(origCell).clone();\n\n\t\t// This is a slightly odd combination of jQuery and DOM, but it is the\n\t\t// fastest and least resource intensive way I could think of cloning\n\t\t// the table with just a single header cell in it.\n\t\tthis.dom.drag = $(origTable.cloneNode(false))\n\t\t\t.addClass( 'DTCR_clonedTable' )\n\t\t\t.append(\n\t\t\t\t$(origThead.cloneNode(false)).append(\n\t\t\t\t\t$(origTr.cloneNode(false)).append(\n\t\t\t\t\t\tcloneCell[0]\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t\t.css( {\n\t\t\t\tposition: 'absolute',\n\t\t\t\ttop: 0,\n\t\t\t\tleft: 0,\n\t\t\t\twidth: $(origCell).outerWidth(),\n\t\t\t\theight: $(origCell).outerHeight()\n\t\t\t} )\n\t\t\t.appendTo( 'body' );\n\n\t\tthis.dom.pointer = $('<div></div>')\n\t\t\t.addClass( 'DTCR_pointer' )\n\t\t\t.css( {\n\t\t\t\tposition: 'absolute',\n\t\t\t\ttop: scrolling ?\n\t\t\t\t\t$('div.dataTables_scroll', this.s.dt.nTableWrapper).offset().top :\n\t\t\t\t\t$(this.s.dt.nTable).offset().top,\n\t\t\t\theight : scrolling ?\n\t\t\t\t\t$('div.dataTables_scroll', this.s.dt.nTableWrapper).height() :\n\t\t\t\t\t$(this.s.dt.nTable).height()\n\t\t\t} )\n\t\t\t.appendTo( 'body' );\n\t},\n\n\n\t/**\n\t * Add a data attribute to the column headers, so we know the index of\n\t * the row to be reordered. This allows fast detection of the index, and\n\t * for this plug-in to work with FixedHeader which clones the nodes.\n\t *  @private\n\t */\n\t\"_fnSetColumnIndexes\": function ()\n\t{\n\t\t$.each( this.s.dt.aoColumns, function (i, column) {\n\t\t\t$(column.nTh).attr('data-column-index', i);\n\t\t} );\n\t}\n} );\n\n\n\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Static parameters\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\n/**\n * ColReorder default settings for initialisation\n *  @namespace\n *  @static\n */\nColReorder.defaults = {\n\t/**\n\t * Predefined ordering for the columns that will be applied automatically\n\t * on initialisation. If not specified then the order that the columns are\n\t * found to be in the HTML is the order used.\n\t *  @type array\n\t *  @default null\n\t *  @static\n\t */\n\taiOrder: null,\n\n\t/**\n\t * Redraw the table's column ordering as the end user draws the column\n\t * (`true`) or wait until the mouse is released (`false` - default). Note\n\t * that this will perform a redraw on each reordering, which involves an\n\t * Ajax request each time if you are using server-side processing in\n\t * DataTables.\n\t *  @type boolean\n\t *  @default false\n\t *  @static\n\t */\n\tbRealtime: true,\n\n\t/**\n\t * Indicate how many columns should be fixed in position (counting from the\n\t * left). This will typically be 1 if used, but can be as high as you like.\n\t *  @type int\n\t *  @default 0\n\t *  @static\n\t */\n\tiFixedColumnsLeft: 0,\n\n\t/**\n\t * As `iFixedColumnsRight` but counting from the right.\n\t *  @type int\n\t *  @default 0\n\t *  @static\n\t */\n\tiFixedColumnsRight: 0,\n\n\t/**\n\t * Callback function that is fired when columns are reordered. The `column-\n\t * reorder` event is preferred over this callback\n\t *  @type function():void\n\t *  @default null\n\t *  @static\n\t */\n\tfnReorderCallback: null\n};\n\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Constants\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/**\n * ColReorder version\n *  @constant  version\n *  @type      String\n *  @default   As code\n */\nColReorder.version = \"1.3.0\";\n\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * DataTables interfaces\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n// Expose\n$.fn.dataTable.ColReorder = ColReorder;\n$.fn.DataTable.ColReorder = ColReorder;\n\n\n// Register a new feature with DataTables\nif ( typeof $.fn.dataTable == \"function\" &&\n     typeof $.fn.dataTableExt.fnVersionCheck == \"function\" &&\n     $.fn.dataTableExt.fnVersionCheck('1.10.8') )\n{\n\t$.fn.dataTableExt.aoFeatures.push( {\n\t\t\"fnInit\": function( settings ) {\n\t\t\tvar table = settings.oInstance;\n\n\t\t\tif ( ! settings._colReorder ) {\n\t\t\t\tvar dtInit = settings.oInit;\n\t\t\t\tvar opts = dtInit.colReorder || dtInit.oColReorder || {};\n\n\t\t\t\tnew ColReorder( settings, opts );\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttable.oApi._fnLog( settings, 1, \"ColReorder attempted to initialise twice. Ignoring second\" );\n\t\t\t}\n\n\t\t\treturn null; /* No node for DataTables to insert */\n\t\t},\n\t\t\"cFeature\": \"R\",\n\t\t\"sFeature\": \"ColReorder\"\n\t} );\n}\nelse {\n\talert( \"Warning: ColReorder requires DataTables 1.10.8 or greater - www.datatables.net/download\");\n}\n\n\n// Attach a listener to the document which listens for DataTables initialisation\n// events so we can automatically initialise\n$(document).on( 'preInit.dt.colReorder', function (e, settings) {\n\tif ( e.namespace !== 'dt' ) {\n\t\treturn;\n\t}\n\n\tvar init = settings.oInit.colReorder;\n\tvar defaults = DataTable.defaults.colReorder;\n\n\tif ( init || defaults ) {\n\t\tvar opts = $.extend( {}, init, defaults );\n\n\t\tif ( init !== false ) {\n\t\t\tnew ColReorder( settings, opts  );\n\t\t}\n\t}\n} );\n\n\n// API augmentation\n$.fn.dataTable.Api.register( 'colReorder.reset()', function () {\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tctx._colReorder.fnReset();\n\t} );\n} );\n\n$.fn.dataTable.Api.register( 'colReorder.order()', function ( set, original ) {\n\tif ( set ) {\n\t\treturn this.iterator( 'table', function ( ctx ) {\n\t\t\tctx._colReorder.fnOrder( set, original );\n\t\t} );\n\t}\n\n\treturn this.context.length ?\n\t\tthis.context[0]._colReorder.fnOrder() :\n\t\tnull;\n} );\n\n$.fn.dataTable.Api.register( 'colReorder.transpose()', function ( idx, dir ) {\n\treturn this.context.length && this.context[0]._colReorder ?\n\t\tthis.context[0]._colReorder.fnTranspose( idx, dir ) :\n\t\tidx;\n} );\n\n\nreturn ColReorder;\n}));"]},"metadata":{},"sourceType":"module"}